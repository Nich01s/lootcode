
「拓扑排序」：
    设G=<V,E>是一个具有n个顶点的有向无环图，V中顶点序列v1,v2,...vn称为一个拓扑排序，当且仅当该顶点按序列满足下列条件：
       若<i,j>是图中的边，则在拓扑序中，顶点i必须排在顶点j之前。
    在一个有向无环图中「找一个拓扑序列的过程」称为拓扑排序，一个有向无环图的拓扑序列不唯一。

「求图的拓扑排序的算法思想」：
    Ⅰ、从有向图中选一个入度为0的顶点输出；
    Ⅱ、将此顶点和以它为起点的所有边删除；
    Ⅲ、重复Ⅰ和Ⅱ，直到不存在入度为0的顶点；
    Ⅳ、若此时输出的顶点数 = 有向无环图中的顶点数，说明输出的顶点顺序是该有向无环图的一个拓扑排序
       若此时输出的顶点数 < 有向无环图中的顶点数，说明有向图中存在环（因为有环就一定会在删除顶点的过程中，某一入度为0的顶点删除完成后，剩下的所有顶点中不再有无入度为0的顶点）

「拓扑排序的算法步骤」:
    Ⅰ、求所有顶点的入度，存储在一个数组种indegree[]；
    Ⅱ、将所有入度为0的顶点入队/栈；
    Ⅲ、当队/栈不为空时：（为什么使用栈/队皆可？因为栈/队中任何时刻存在的顶点都是入度为0的顶点，先输入哪个没有顺序上的要求）
          ①.出队/栈顶点u，输出顶点u；
          ②.顶点u的所有邻接点入度-1，如果有入度为0的顶点，则入队/栈；
    Ⅳ、若此时出书的顶点数小于有向图中的顶点数，说明图中有环，否则输出的顶点顺序就是该图的一个拓扑排序；

「拓扑排序代码模板」：
   List<List<Integer>> edges;//邻接表（已初始化）
   int[] indegree;//入度数组（已初始化）
   List<Integer> res = new ArrayList<>();//存储输出序列
   Queue<Integer> queue = new LinkedList<>();//辅助队列
   for(int i = 0;i<n;i++){
       if(indegree[i]==0) queue.offer(i);//初始化辅助队列，入队入度为0的节点
   }
   while(!queue.isEmpty()){
       int node = queue.poll();
       res.add(node);
       for(int i = 0;i<edges.get(node).size();i++){
           int temp = edges.get(node).get(i);
           indegree[temp]--;
           if(indegree[temp]==0){
               queue.offer(temp);
           }
       }
   }